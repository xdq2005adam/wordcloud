<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å®æ—¶è¯äº‘å±•ç¤º</title>
    <script src="/lib/wordcloud2.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            overflow: hidden;
        }

        .container {
            display: flex;
            width: 100%;
            height: 100vh;
        }

        .left-panel {
            width: 350px;
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.1);
            z-index: 10;
        }

        .left-panel h1 {
            color: #333;
            margin-bottom: 20px;
            font-size: 24px;
            text-align: center;
        }

        .qrcode-container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }

        .reset-button {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            box-shadow: 0 4px 15px rgba(245, 87, 108, 0.4);
        }

        .reset-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(245, 87, 108, 0.6);
        }

        .reset-button:active {
            transform: translateY(0);
        }

        #qrcode-image {
            display: block;
            margin: 0 auto;
            max-width: 100%;
            height: auto;
        }


        .right-panel {
            flex: 1;
            background: rgba(255, 255, 255, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            position: relative;
            overflow: hidden;
        }

        #wordcloud-canvas {
            width: 100% !important;
            height: 100% !important;
        }

        .status {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(76, 175, 80, 0.9);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        .status.offline {
            background: rgba(244, 67, 54, 0.9);
        }

        .refresh-notice {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 152, 0, 0.95);
            color: white;
            padding: 30px 40px;
            border-radius: 15px;
            font-size: 18px;
            text-align: center;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            min-width: 300px;
        }

        .refresh-notice p {
            margin: 10px 0;
        }

        .refresh-notice .countdown {
            font-size: 24px;
            font-weight: bold;
            color: #fff;
            margin-top: 15px;
        }

        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }

            .left-panel {
                width: 100%;
                height: auto;
                padding: 20px;
            }

            .right-panel {
                height: calc(100vh - 300px);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="left-panel">
            <h1>ğŸ“± æ‰«æäºŒç»´ç å‘é€æ¶ˆæ¯</h1>
            <div class="qrcode-container">
                <img src="/qr_code.png" alt="æ‰«æäºŒç»´ç å‘é€æ¶ˆæ¯" id="qrcode-image" style="width: 250px; height: 250px; display: block; margin: 0 auto;">
            </div>
            <button class="reset-button" id="resetBtn">ğŸ”„ é‡ç½®è¯äº‘</button>
        </div>
        <div class="right-panel">
            <canvas id="wordcloud-canvas"></canvas>
        </div>
    </div>
    
    <!-- åˆ·æ–°æç¤ºæ¡† -->
    <div class="refresh-notice" id="refresh-notice" style="display: none;">
        <p>è¯äº‘ç©ºé—´å·²æ»¡ï¼Œæ— æ³•æ”¾ç½®æ›´å¤šè¯</p>
        <p>é¡µé¢å°†åœ¨ <span class="countdown" id="countdown">3</span> ç§’åè‡ªåŠ¨åˆ·æ–°</p>
        <p style="font-size: 14px; margin-top: 10px;">åˆ·æ–°åå°†é‡æ–°å¸ƒå±€æ‰€æœ‰è¯</p>
    </div>

    <script>
        // ç­‰å¾…DOMå’Œæ‰€æœ‰èµ„æºåŠ è½½å®Œæˆ
        document.addEventListener('DOMContentLoaded', function() {
            // äºŒç»´ç å·²ä½¿ç”¨é™æ€å›¾ç‰‡ qr_code.pngï¼Œæ— éœ€åŠ¨æ€ç”Ÿæˆ
            console.log('âœ“ ä½¿ç”¨é™æ€äºŒç»´ç å›¾ç‰‡: /qr_code.png');

            // æ£€æŸ¥socket.ioæ˜¯å¦åŠ è½½
            if (typeof io === 'undefined') {
                console.error('âŒ socket.ioæœªåŠ è½½ï¼è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–æœåŠ¡å™¨æ˜¯å¦è¿è¡Œ');
                alert('socket.ioåº“æœªåŠ è½½ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•');
            } else {
                console.log('âœ“ socket.ioå·²åŠ è½½');
            }

            // æ£€æŸ¥WordCloud2æ˜¯å¦åŠ è½½
            function checkWordCloud() {
                if (typeof WordCloud === 'undefined') {
                    console.warn('âš  WordCloud2åº“æœªåŠ è½½ï¼Œæ­£åœ¨é‡è¯•...');
                    return false;
                } else {
                    console.log('âœ“ WordCloud2åº“å·²åŠ è½½');
                    return true;
                }
            }
            
            // å»¶è¿Ÿæ£€æŸ¥ï¼Œç¡®ä¿åº“å·²åŠ è½½
            setTimeout(() => {
                if (!checkWordCloud()) {
                    console.error('âŒ WordCloud2åº“åŠ è½½å¤±è´¥ï¼');
                    console.log('æç¤ºï¼šè¯·ç¡®ä¿ /lib/wordcloud2.js æ–‡ä»¶å­˜åœ¨');
                    // å°è¯•ä½¿ç”¨å¤‡ç”¨CDNä½œä¸ºæœ€åæ‰‹æ®µ
                    const script = document.createElement('script');
                    script.src = 'https://unpkg.com/wordcloud@1.2.2/build/wordcloud2.min.js';
                    script.onload = () => {
                        console.log('âœ“ WordCloud2åº“ä»å¤‡ç”¨CDNåŠ è½½æˆåŠŸ');
                        if (checkWordCloud() && typeof wordCount !== 'undefined' && Object.keys(wordCount).length > 0) {
                            updateWordCloud(); // å¦‚æœå·²æœ‰æ•°æ®ï¼Œç«‹å³æ›´æ–°è¯äº‘
                        }
                    };
                    script.onerror = () => {
                        console.error('âŒ å¤‡ç”¨CDNä¹ŸåŠ è½½å¤±è´¥');
                    };
                    document.head.appendChild(script);
                }
            }, 500);

            // è¿æ¥WebSocket
            console.log('æ­£åœ¨è¿æ¥WebSocketæœåŠ¡å™¨...');
            const socket = io();

            socket.on('connect', () => {
                console.log('âœ“ WebSocketè¿æ¥æˆåŠŸï¼Socket ID:', socket.id);
            });

            socket.on('connect_error', (error) => {
                console.error('âŒ WebSocketè¿æ¥å¤±è´¥:', error);
            });

            socket.on('disconnect', (reason) => {
                console.warn('âš  WebSocketæ–­å¼€è¿æ¥:', reason);
            });

            // å­˜å‚¨è¯é¢‘ç»Ÿè®¡
            const wordCount = {};

            // æ¥æ”¶æ–°æ¶ˆæ¯
            console.log('æ³¨å†ŒnewMessageäº‹ä»¶ç›‘å¬å™¨...');
            socket.on('newMessage', (data) => {
                console.log('========== æ”¶åˆ°æ–°æ¶ˆæ¯ ==========');
                console.log('å®Œæ•´æ•°æ®:', JSON.stringify(data, null, 2));
                console.log('æ¶ˆæ¯æ–‡æœ¬:', data.text);
                const text = data.text?.trim();
                if (!text) {
                    console.log('æ¶ˆæ¯ä¸ºç©ºï¼Œè·³è¿‡');
                    return;
                }

                // ç®€å•åˆ†è¯ï¼ˆä¸­æ–‡æŒ‰å­—ç¬¦ï¼Œè‹±æ–‡æŒ‰å•è¯ï¼‰
                // å…ˆæŒ‰æ ‡ç‚¹ç¬¦å·åˆ†å‰²ï¼Œç„¶åè¿‡æ»¤ç©ºå­—ç¬¦ä¸²
                const words = text.split(/[\s,ï¼Œã€‚ï¼ï¼Ÿã€ï¼›ï¼š\n\r]+/).filter(w => w.length > 0);
                
                console.log('åˆ†è¯ç»“æœ:', words);
                
                words.forEach(word => {
                    if (wordCount[word]) {
                        wordCount[word] += 1;
                    } else {
                        wordCount[word] = 1;
                    }
                });

                console.log('å½“å‰è¯é¢‘ç»Ÿè®¡:', wordCount);

                // æ›´æ–°è¯äº‘æ•°æ®
                updateWordCloud();
            });

            // ä¸ºæ¯ä¸ªè¯å­˜å‚¨å›ºå®šçš„é¢œè‰²å’Œå¤§å°æƒé‡ï¼ˆç¡®ä¿å¢é‡æ·»åŠ æ—¶ä¿æŒä¸€è‡´ï¼‰
            const wordProperties = {}; // {word: {color, weight}}
            
            // è®°å½•å·²æ”¾ç½®çš„è¯çš„ä¿¡æ¯ï¼ˆç”¨äºå¢é‡æ·»åŠ ï¼‰
            const placedWords = []; // [{word, fontSize, color, x, y, width, height}]
            
            // å·²ä½¿ç”¨çš„é¢œè‰²åˆ—è¡¨ï¼ˆç”¨äºé¿å…ç›¸ä¼¼é¢œè‰²ï¼‰
            const usedColors = []; // å­˜å‚¨HSLæ ¼å¼çš„é¢œè‰²
            
            // é¢œè‰²å·¥å…·å‡½æ•°
            const colorUtils = {
                // å°†åå…­è¿›åˆ¶é¢œè‰²è½¬æ¢ä¸ºRGB
                hexToRgb(hex) {
                    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                    return result ? {
                        r: parseInt(result[1], 16),
                        g: parseInt(result[2], 16),
                        b: parseInt(result[3], 16)
                    } : null;
                },
                
                // å°†RGBè½¬æ¢ä¸ºHSL
                rgbToHsl(r, g, b) {
                    r /= 255;
                    g /= 255;
                    b /= 255;
                    const max = Math.max(r, g, b);
                    const min = Math.min(r, g, b);
                    let h, s, l = (max + min) / 2;
                    
                    if (max === min) {
                        h = s = 0; // æ— è‰²å½©
                    } else {
                        const d = max - min;
                        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                        switch (max) {
                            case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                            case g: h = ((b - r) / d + 2) / 6; break;
                            case b: h = ((r - g) / d + 4) / 6; break;
                        }
                    }
                    return { h: h * 360, s: s * 100, l: l * 100 };
                },
                
                // å°†HSLè½¬æ¢ä¸ºRGB
                hslToRgb(h, s, l) {
                    h /= 360;
                    s /= 100;
                    l /= 100;
                    let r, g, b;
                    
                    if (s === 0) {
                        r = g = b = l; // æ— è‰²å½©
                    } else {
                        const hue2rgb = (p, q, t) => {
                            if (t < 0) t += 1;
                            if (t > 1) t -= 1;
                            if (t < 1/6) return p + (q - p) * 6 * t;
                            if (t < 1/2) return q;
                            if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                            return p;
                        };
                        
                        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                        const p = 2 * l - q;
                        r = hue2rgb(p, q, h + 1/3);
                        g = hue2rgb(p, q, h);
                        b = hue2rgb(p, q, h - 1/3);
                    }
                    
                    return {
                        r: Math.round(r * 255),
                        g: Math.round(g * 255),
                        b: Math.round(b * 255)
                    };
                },
                
                // å°†RGBè½¬æ¢ä¸ºåå…­è¿›åˆ¶
                rgbToHex(r, g, b) {
                    return '#' + [r, g, b].map(x => {
                        const hex = x.toString(16);
                        return hex.length === 1 ? '0' + hex : hex;
                    }).join('');
                },
                
                // è®¡ç®—ä¸¤ä¸ªHSLé¢œè‰²çš„å·®å¼‚
                colorDifference(hsl1, hsl2) {
                    // è‰²ç›¸å·®ï¼ˆè€ƒè™‘è‰²ç¯çš„å¾ªç¯ç‰¹æ€§ï¼‰
                    let hDiff = Math.abs(hsl1.h - hsl2.h);
                    if (hDiff > 180) hDiff = 360 - hDiff;
                    
                    // é¥±å’Œåº¦å’Œäº®åº¦å·®
                    const sDiff = Math.abs(hsl1.s - hsl2.s);
                    const lDiff = Math.abs(hsl1.l - hsl2.l);
                    
                    // ç»¼åˆå·®å¼‚ï¼ˆè‰²ç›¸æƒé‡æ›´é«˜ï¼‰
                    return hDiff * 2 + sDiff * 0.5 + lDiff * 0.5;
                },
                
                // æ£€æŸ¥é¢œè‰²æ˜¯å¦ä¸å·²æœ‰é¢œè‰²å·®å¼‚è¶³å¤Ÿå¤§
                isColorDifferent(newHsl, minDifference = 40) {
                    for (const usedHsl of usedColors) {
                        const diff = this.colorDifference(newHsl, usedHsl);
                        if (diff < minDifference) {
                            return false;
                        }
                    }
                    return true;
                },
                
                // ç”Ÿæˆä¸€ä¸ªä¸å·²æœ‰é¢œè‰²å·®å¼‚è¶³å¤Ÿå¤§çš„æ–°é¢œè‰²
                generateDifferentColor(baseHue, attempts = 50) {
                    // å°è¯•ä¸åŒçš„è‰²ç›¸ã€é¥±å’Œåº¦å’Œäº®åº¦ç»„åˆ
                    for (let attempt = 0; attempt < attempts; attempt++) {
                        // è‰²ç›¸ï¼šåœ¨åŸºç¡€è‰²ç›¸å‘¨å›´åˆ†æ•£ï¼Œä½†é¿å…å¤ªæ¥è¿‘å·²æœ‰é¢œè‰²
                        const hue = (baseHue + attempt * 137.5) % 360; // ä½¿ç”¨é»„é‡‘è§’ï¼ˆ137.5åº¦ï¼‰åˆ†æ•£
                        
                        // é¥±å’Œåº¦å’Œäº®åº¦ï¼šåœ¨åˆç†èŒƒå›´å†…å˜åŒ–ï¼Œç¡®ä¿é¢œè‰²é²œè‰³ä½†ä¸åˆºçœ¼
                        const saturation = 60 + (attempt % 3) * 15; // 60-90%
                        const lightness = 45 + (attempt % 4) * 10; // 45-75%
                        
                        const newHsl = { h: hue, s: saturation, l: lightness };
                        
                        if (this.isColorDifferent(newHsl, 35)) {
                            return newHsl;
                        }
                    }
                    
                    // å¦‚æœ50æ¬¡å°è¯•éƒ½å¤±è´¥ï¼Œè¿”å›ä¸€ä¸ªç›¸å¯¹å·®å¼‚æœ€å¤§çš„
                    let bestHsl = null;
                    let maxMinDiff = 0;
                    
                    for (let i = 0; i < 100; i++) {
                        const hue = (baseHue + i * 137.5) % 360;
                        const saturation = 60 + (i % 3) * 15;
                        const lightness = 45 + (i % 4) * 10;
                        const testHsl = { h: hue, s: saturation, l: lightness };
                        
                        let minDiff = Infinity;
                        for (const usedHsl of usedColors) {
                            const diff = this.colorDifference(testHsl, usedHsl);
                            minDiff = Math.min(minDiff, diff);
                        }
                        
                        if (minDiff > maxMinDiff) {
                            maxMinDiff = minDiff;
                            bestHsl = testHsl;
                        }
                    }
                    
                    return bestHsl || { h: baseHue, s: 70, l: 55 };
                }
            };
            
            // è·å–æ‰€æœ‰å·²æœ‰è¯çš„é¢œè‰²HSLåˆ—è¡¨ï¼ˆç”¨äºé¢œè‰²å·®å¼‚æ£€æµ‹ï¼‰
            function getAllUsedColorsHsl() {
                const allHsl = [...usedColors]; // å¤åˆ¶å·²ä½¿ç”¨é¢œè‰²åˆ—è¡¨
                
                // å°†å·²ä¿å­˜çš„è¯çš„é¢œè‰²ä¹Ÿè½¬æ¢ä¸ºHSLå¹¶åŠ å…¥åˆ—è¡¨
                for (const word in wordProperties) {
                    if (wordProperties[word].color) {
                        const rgb = colorUtils.hexToRgb(wordProperties[word].color);
                        if (rgb) {
                            const hsl = colorUtils.rgbToHsl(rgb.r, rgb.g, rgb.b);
                            // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ï¼ˆé¿å…é‡å¤ï¼‰
                            let exists = false;
                            for (const existingHsl of allHsl) {
                                if (colorUtils.colorDifference(hsl, existingHsl) < 10) {
                                    exists = true;
                                    break;
                                }
                            }
                            if (!exists) {
                                allHsl.push(hsl);
                            }
                        }
                    }
                }
                
                return allHsl;
            }
            
            // ç”Ÿæˆéšæœºé¢œè‰²ï¼ˆåŸºäºè¯çš„å“ˆå¸Œï¼Œç¡®ä¿åŒä¸€è¯æ€»æ˜¯ç›¸åŒé¢œè‰²ï¼Œä¸”é¿å…ç›¸ä¼¼é¢œè‰²ï¼‰
            function getColorForWord(word) {
                if (wordProperties[word] && wordProperties[word].color) {
                    return wordProperties[word].color;
                }
                
                // åŸºäºè¯çš„å“ˆå¸Œç”ŸæˆåŸºç¡€è‰²ç›¸ï¼Œç¡®ä¿åŒä¸€è¯æ€»æ˜¯ç›¸åŒé¢œè‰²
                let hash = 0;
                for (let i = 0; i < word.length; i++) {
                    hash = word.charCodeAt(i) + ((hash << 5) - hash);
                }
                const baseHue = Math.abs(hash) % 360;
                
                // è·å–æ‰€æœ‰å·²æœ‰é¢œè‰²çš„HSLåˆ—è¡¨ï¼ˆåŒ…æ‹¬å·²ä¿å­˜çš„è¯ï¼‰
                const allUsedHsl = getAllUsedColorsHsl();
                
                // ä¸´æ—¶æ›¿æ¢usedColorsä»¥ä¾¿generateDifferentColorä½¿ç”¨
                const originalUsedColors = [...usedColors];
                usedColors.length = 0;
                usedColors.push(...allUsedHsl);
                
                // ç”Ÿæˆä¸å·²æœ‰é¢œè‰²å·®å¼‚è¶³å¤Ÿå¤§çš„æ–°é¢œè‰²
                const newHsl = colorUtils.generateDifferentColor(baseHue);
                
                // æ¢å¤usedColorså¹¶æ·»åŠ æ–°é¢œè‰²
                usedColors.length = 0;
                usedColors.push(...originalUsedColors);
                usedColors.push(newHsl);
                
                // å°†HSLè½¬æ¢ä¸ºRGBå†è½¬æ¢ä¸ºåå…­è¿›åˆ¶
                const rgb = colorUtils.hslToRgb(newHsl.h, newHsl.s, newHsl.l);
                const color = colorUtils.rgbToHex(rgb.r, rgb.g, rgb.b);
                
                // ä¿å­˜é¢œè‰²
                if (!wordProperties[word]) {
                    wordProperties[word] = {};
                }
                wordProperties[word].color = color;
                
                return color;
            }
            
            // è·å–è¯çš„å›ºå®šæƒé‡ï¼ˆåŸºäºè¯çš„å“ˆå¸Œï¼Œç¡®ä¿åŒä¸€è¯æ€»æ˜¯ç›¸åŒå¤§å°ï¼‰
            function getWeightForWord(word) {
                if (wordProperties[word] && wordProperties[word].weight !== undefined) {
                    return wordProperties[word].weight;
                }
                
                // åŸºäºè¯çš„å“ˆå¸Œç”Ÿæˆæƒé‡ï¼ˆ0-1ï¼‰ï¼Œç¡®ä¿åŒä¸€è¯æ€»æ˜¯ç›¸åŒå¤§å°
                let hash = 0;
                for (let i = 0; i < word.length; i++) {
                    hash = word.charCodeAt(i) + ((hash << 5) - hash);
                }
                const weight = Math.abs(hash) % 1000 / 1000; // 0-1ä¹‹é—´çš„å€¼
                
                // ä¿å­˜æƒé‡
                if (!wordProperties[word]) {
                    wordProperties[word] = {};
                }
                wordProperties[word].weight = weight;
                
                return weight;
            }

            // æ›´æ–°è¯äº‘ï¼ˆå¢é‡æ·»åŠ æ¨¡å¼ï¼šä¿ç•™å·²å­˜åœ¨çš„è¯ï¼Œåªæ·»åŠ æ–°è¯ï¼‰
            function updateWordCloud() {
                const canvas = document.getElementById('wordcloud-canvas');
                
                // ç¡®ä¿canvasæœ‰æ˜ç¡®çš„åƒç´ å°ºå¯¸
                if (!canvas.width || !canvas.height) {
                    const rect = canvas.getBoundingClientRect();
                    canvas.width = rect.width || 800;
                    canvas.height = rect.height || 600;
                }
                
                const wordCountKeys = Object.keys(wordCount);
                
                if (wordCountKeys.length === 0) {
                    // å¦‚æœæ²¡æœ‰æ•°æ®ï¼Œæ˜¾ç¤ºæç¤º
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#999';
                    ctx.font = '24px Microsoft YaHei';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('ç­‰å¾…æ¶ˆæ¯...', canvas.width / 2, canvas.height / 2);
                    placedWords.length = 0; // æ¸…ç©ºå·²æ”¾ç½®çš„è¯
                    return;
                }
                
                // æ£€æŸ¥æ˜¯å¦æœ‰æ–°è¯
                const existingWords = new Set(placedWords.map(p => p.word));
                const allWords = Object.keys(wordCount);
                const newWords = allWords.filter(word => !existingWords.has(word));
                
                // å¦‚æœæ²¡æœ‰æ–°è¯ï¼Œä¸éœ€è¦æ›´æ–°
                if (newWords.length === 0 && placedWords.length > 0) {
                    return;
                }
                
                // ä¸ºæ¯ä¸ªè¯ç”Ÿæˆé¢œè‰²æ˜ å°„å’Œå›ºå®šæƒé‡
                const colorMap = {};
                const maxSize = Math.min(canvas.width / 8, 100);
                const minSize = Math.max(canvas.width / 40, 20);
                
                // å‡†å¤‡æ‰€æœ‰è¯çš„åˆ—è¡¨ï¼ˆä¿æŒå›ºå®šé¡ºåºä»¥ä¾¿é¢œè‰²å’Œå¤§å°ä¸€è‡´ï¼‰
                const list = allWords.map(word => {
                    colorMap[word] = getColorForWord(word);
                    return [word, getWeightForWord(word)];
                });
                
                console.log('å‡†å¤‡ç”Ÿæˆè¯äº‘ï¼Œæ–°è¯:', newWords.length, 'æ€»è¯æ•°:', allWords.length);
                
                // ç¡®ä¿canvaså°ºå¯¸æ­£ç¡®
                const rect = canvas.getBoundingClientRect();
                canvas.width = rect.width;
                canvas.height = rect.height;
                
                // æ£€æŸ¥WordCloudå‡½æ•°æ˜¯å¦å­˜åœ¨
                if (typeof WordCloud === 'undefined') {
                    console.warn('WordCloud2åº“æœªåŠ è½½ï¼Œç­‰å¾…åŠ è½½...');
                    setTimeout(() => {
                        if (typeof WordCloud !== 'undefined') {
                            updateWordCloud();
                        } else {
                            console.error('WordCloud2åº“ä»æœªåŠ è½½ï¼Œè¯·æ£€æŸ¥CDNé“¾æ¥æˆ–ç½‘ç»œè¿æ¥');
                        }
                    }, 1000);
                    return;
                }
                
                try {
                    // ä½¿ç”¨è‡ªå®šä¹‰å¸ƒå±€ç®—æ³•å®ç°çœŸæ­£çš„éšæœºåˆ†å¸ƒ
                    // å¢é‡æ·»åŠ æ¨¡å¼ï¼šä¿æŒå·²æœ‰è¯çš„ä½ç½®ä¸å˜ï¼Œåªä¸ºæ–°è¯åˆ†é…ä½ç½®
                    
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // æ¢å¤å·²æ”¾ç½®è¯çš„ä½ç½®ä¿¡æ¯ï¼ˆä»ä¸Šæ¬¡ä¿å­˜çš„è®°å½•ä¸­ï¼‰
                    const placed = [];
                    const existingWordsMap = new Map(); // ç”¨äºå¿«é€ŸæŸ¥æ‰¾å·²æœ‰è¯
                    
                    // å…ˆæ¢å¤å·²æœ‰è¯çš„ä½ç½®ä¿¡æ¯
                    placedWords.forEach(item => {
                        if (item.x !== undefined && item.y !== undefined) {
                            // å·²æœ‰å®Œæ•´ä½ç½®ä¿¡æ¯ï¼Œç›´æ¥æ¢å¤
                            placed.push({
                                word: item.word,
                                x: item.x,
                                y: item.y,
                                width: item.width,
                                height: item.height,
                                fontSize: item.fontSize,
                                color: item.color
                            });
                            existingWordsMap.set(item.word, true);
                        }
                    });
                    
                    // å…ˆç»˜åˆ¶æ‰€æœ‰å·²æœ‰è¯ï¼ˆä¿æŒåŸæœ‰ä½ç½®ï¼‰
                    placed.forEach(item => {
                        ctx.fillStyle = item.color;
                        ctx.font = `${item.fontSize}px Microsoft YaHei, Arial, sans-serif`;
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'top';
                        ctx.fillText(item.word, item.x, item.y);
                    });
                    
                    // æ‰¾å‡ºéœ€è¦æ·»åŠ çš„æ–°è¯
                    const newWordsList = list.filter(([word, weight]) => !existingWordsMap.has(word));
                    
                    // æŒ‰æƒé‡æ’åºæ–°è¯ï¼Œå¤§çš„è¯å…ˆæ”¾ç½®
                    const sortedNewWords = newWordsList.slice().sort((a, b) => b[1] - a[1]);
                    
                    const padding = 20; // è¾¹è·
                    
                    // çŸ©å½¢ç›¸äº¤æ£€æµ‹å‡½æ•°
                    function checkRectCollision(rect1, rect2) {
                        // rect = {x, y, width, height}
                        return !(rect1.x + rect1.width < rect2.x ||
                                rect2.x + rect2.width < rect1.x ||
                                rect1.y + rect1.height < rect2.y ||
                                rect2.y + rect2.height < rect1.y);
                    }
                    
                    // å°è¯•æ‰¾åˆ°ä¸€ä¸ªä¸ç¢°æ’çš„ä½ç½®ï¼ˆæ”¯æŒå¤šç§æœç´¢ç­–ç•¥ï¼‰
                    function findPosition(word, fontSize, color, spacing, maxAttempts = 300) {
                        ctx.font = `${fontSize}px Microsoft YaHei, Arial, sans-serif`;
                        const metrics = ctx.measureText(word);
                        const textWidth = metrics.width;
                        const textHeight = fontSize;
                        
                        // å¦‚æœæ–‡å­—å¤ªå¤§ï¼Œç›´æ¥è¿”å›å¤±è´¥
                        if (textWidth > canvas.width - padding * 2 || textHeight > canvas.height - padding * 2) {
                            return null;
                        }
                        
                        // ç­–ç•¥1: éšæœºæœç´¢
                        for (let i = 0; i < Math.min(maxAttempts, 200); i++) {
                            const x = padding + Math.random() * (canvas.width - textWidth - padding * 2);
                            const y = padding + Math.random() * (canvas.height - textHeight - padding * 2);
                            
                            const currentRect = {
                                x: x - spacing,
                                y: y - spacing,
                                width: textWidth + spacing * 2,
                                height: textHeight + spacing * 2
                            };
                            
                            let collision = false;
                            for (const placedItem of placed) {
                                const placedRect = {
                                    x: placedItem.x - spacing,
                                    y: placedItem.y - spacing,
                                    width: placedItem.width + spacing * 2,
                                    height: placedItem.height + spacing * 2
                                };
                                
                                if (checkRectCollision(currentRect, placedRect)) {
                                    collision = true;
                                    break;
                                }
                            }
                            
                            if (!collision) {
                                return {x, y, textWidth, textHeight};
                            }
                        }
                        
                        // ç­–ç•¥2: ç½‘æ ¼æœç´¢ï¼ˆæ›´ç³»ç»ŸåŒ–ï¼‰
                        const gridSize = 30;
                        const cols = Math.floor((canvas.width - padding * 2) / gridSize);
                        const rows = Math.floor((canvas.height - padding * 2) / gridSize);
                        
                        // éšæœºæ‰“ä¹±ç½‘æ ¼é¡ºåºï¼Œé¿å…æ€»æ˜¯ä»å·¦ä¸Šè§’å¼€å§‹
                        const gridPositions = [];
                        for (let row = 0; row < rows; row++) {
                            for (let col = 0; col < cols; col++) {
                                gridPositions.push({row, col});
                            }
                        }
                        // éšæœºæ‰“ä¹±
                        for (let i = gridPositions.length - 1; i > 0; i--) {
                            const j = Math.floor(Math.random() * (i + 1));
                            [gridPositions[i], gridPositions[j]] = [gridPositions[j], gridPositions[i]];
                        }
                        
                        for (const {row, col} of gridPositions) {
                            const x = padding + col * gridSize;
                            const y = padding + row * gridSize;
                            
                            // ç¡®ä¿åœ¨ç”»å¸ƒå†…
                            if (x + textWidth > canvas.width - padding || y + textHeight > canvas.height - padding) {
                                continue;
                            }
                            
                            const currentRect = {
                                x: x - spacing,
                                y: y - spacing,
                                width: textWidth + spacing * 2,
                                height: textHeight + spacing * 2
                            };
                            
                            let collision = false;
                            for (const placedItem of placed) {
                                const placedRect = {
                                    x: placedItem.x - spacing,
                                    y: placedItem.y - spacing,
                                    width: placedItem.width + spacing * 2,
                                    height: placedItem.height + spacing * 2
                                };
                                
                                if (checkRectCollision(currentRect, placedRect)) {
                                    collision = true;
                                    break;
                                }
                            }
                            
                            if (!collision) {
                                return {x, y, textWidth, textHeight};
                            }
                        }
                        
                        // ç­–ç•¥3: è¾¹ç¼˜æœç´¢ï¼ˆå°è¯•ç”»å¸ƒè¾¹ç¼˜ï¼‰
                        const edgePositions = [
                            {x: padding, y: padding + Math.random() * (canvas.height - textHeight - padding * 2)},
                            {x: canvas.width - textWidth - padding, y: padding + Math.random() * (canvas.height - textHeight - padding * 2)},
                            {x: padding + Math.random() * (canvas.width - textWidth - padding * 2), y: padding},
                            {x: padding + Math.random() * (canvas.width - textWidth - padding * 2), y: canvas.height - textHeight - padding}
                        ];
                        
                        for (const pos of edgePositions) {
                            if (pos.x < padding || pos.x + textWidth > canvas.width - padding ||
                                pos.y < padding || pos.y + textHeight > canvas.height - padding) {
                                continue;
                            }
                            
                            const currentRect = {
                                x: pos.x - spacing,
                                y: pos.y - spacing,
                                width: textWidth + spacing * 2,
                                height: textHeight + spacing * 2
                            };
                            
                            let collision = false;
                            for (const placedItem of placed) {
                                const placedRect = {
                                    x: placedItem.x - spacing,
                                    y: placedItem.y - spacing,
                                    width: placedItem.width + spacing * 2,
                                    height: placedItem.height + spacing * 2
                                };
                                
                                if (checkRectCollision(currentRect, placedRect)) {
                                    collision = true;
                                    break;
                                }
                            }
                            
                            if (!collision) {
                                return {x: pos.x, y: pos.y, textWidth, textHeight};
                            }
                        }
                        
                        return null; // æ‰¾ä¸åˆ°ä½ç½®
                    }
                    
                    // åªä¸ºæ–°è¯åˆ†é…ä½ç½®ï¼ˆæ”¯æŒåŠ¨æ€è°ƒæ•´å¤§å°ï¼‰
                    let failedWords = [];
                    
                    sortedNewWords.forEach(([word, weight]) => {
                        const originalFontSize = minSize + weight * (maxSize - minSize);
                        const color = colorMap[word] || getColorForWord(word);
                        
                        let fontSize = originalFontSize;
                        let found = false;
                        let position = null;
                        const minAllowedSize = Math.max(8, minSize * 0.5); // æœ€å°å…è®¸å­—ä½“å¤§å°
                        
                        // å°è¯•å¤šç§å­—ä½“å¤§å°ï¼Œä»å¤§åˆ°å°
                        while (fontSize >= minAllowedSize && !found) {
                            // å°è¯•ä¸åŒçš„é—´è·
                            const spacingOptions = [5, 3, 2, 1];
                            
                            for (const spacing of spacingOptions) {
                                position = findPosition(word, fontSize, color, spacing);
                                
                                if (position) {
                                    found = true;
                                    break;
                                }
                            }
                            
                            // å¦‚æœå½“å‰å¤§å°æ‰¾ä¸åˆ°ï¼Œç¼©å°å­—ä½“é‡è¯•
                            if (!found) {
                                fontSize = Math.max(minAllowedSize, fontSize * 0.85); // ç¼©å°15%
                            }
                        }
                        
                        if (found && position) {
                            // ç»˜åˆ¶æ–°è¯
                            ctx.fillStyle = color;
                            ctx.font = `${fontSize}px Microsoft YaHei, Arial, sans-serif`;
                            ctx.textAlign = 'left';
                            ctx.textBaseline = 'top';
                            ctx.fillText(word, position.x, position.y);
                            
                            // è®°å½•æ–°æ”¾ç½®çš„è¯ï¼ˆä¿å­˜å®é™…ä½¿ç”¨çš„å­—ä½“å¤§å°ï¼‰
                            placed.push({
                                word: word,
                                x: position.x,
                                y: position.y,
                                width: position.textWidth,
                                height: position.textHeight,
                                fontSize: fontSize,
                                color: color,
                                originalWeight: weight // ä¿å­˜åŸå§‹æƒé‡
                            });
                            
                            // å¦‚æœå­—ä½“è¢«ç¼©å°äº†ï¼Œæ›´æ–°wordPropertiesä¸­çš„æƒé‡
                            if (fontSize < originalFontSize) {
                                const scaleFactor = fontSize / originalFontSize;
                                wordProperties[word] = {
                                    ...wordProperties[word],
                                    adjustedSize: fontSize,
                                    originalSize: originalFontSize
                                };
                            }
                        } else {
                            // å®Œå…¨æ”¾ä¸ä¸‹çš„è¯
                            failedWords.push(word);
                            console.warn(`æ— æ³•æ”¾ç½®è¯: ${word}ï¼Œå·²å°è¯•æœ€å°å­—ä½“å¤§å° ${minAllowedSize}px`);
                        }
                    });
                    
                    // å¦‚æœæœ‰è¯æ”¾ä¸ä¸‹ï¼Œåˆ·æ–°é¡µé¢
                    if (failedWords.length > 0) {
                        console.warn(`æ— æ³•æ”¾ç½® ${failedWords.length} ä¸ªè¯ï¼Œå‡†å¤‡åˆ·æ–°é¡µé¢é‡æ–°å¸ƒå±€:`, failedWords);
                        
                        // æ˜¾ç¤ºåˆ·æ–°æç¤º
                        const refreshNotice = document.getElementById('refresh-notice');
                        const countdownElement = document.getElementById('countdown');
                        if (refreshNotice && countdownElement) {
                            refreshNotice.style.display = 'block';
                            
                            let countdown = 3;
                            countdownElement.textContent = countdown;
                            
                            const countdownInterval = setInterval(() => {
                                countdown--;
                                if (countdown > 0) {
                                    countdownElement.textContent = countdown;
                                } else {
                                    clearInterval(countdownInterval);
                                    // æ¸…ç©ºå·²æ”¾ç½®çš„è¯ï¼Œè®©ä¸‹æ¬¡é‡æ–°å¸ƒå±€
                                    placedWords.length = 0;
                                    // åˆ·æ–°é¡µé¢
                                    window.location.reload();
                                }
                            }, 1000);
                        } else {
                            // å¦‚æœæ‰¾ä¸åˆ°å…ƒç´ ï¼Œç›´æ¥åˆ·æ–°
                            placedWords.length = 0;
                            setTimeout(() => {
                                window.location.reload();
                            }, 1000);
                        }
                        
                        return; // æå‰è¿”å›ï¼Œä¸æ›´æ–°placedWords
                    }
                    
                    // æ›´æ–°å·²æ”¾ç½®è¯çš„å®Œæ•´è®°å½•ï¼ˆåŒ…æ‹¬ä½ç½®ä¿¡æ¯ï¼‰
                    placedWords.length = 0;
                    placed.forEach(item => {
                        placedWords.push({
                            word: item.word,
                            color: item.color,
                            fontSize: item.fontSize,
                            x: item.x,
                            y: item.y,
                            width: item.width,
                            height: item.height
                        });
                    });
                    
                    console.log('è¯äº‘ç”ŸæˆæˆåŠŸï¼ˆè‡ªå®šä¹‰éšæœºå¸ƒå±€ï¼‰ï¼Œæ–°è¯:', sortedNewWords.length, 'å·²æœ‰è¯:', placed.length - sortedNewWords.length);
                } catch (error) {
                    console.error('ç”Ÿæˆè¯äº‘æ—¶å‡ºé”™:', error);
                    console.error('é”™è¯¯è¯¦æƒ…:', error.stack);
                }
            }

            // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
            window.addEventListener('load', () => {
                // åˆå§‹åŒ–canvaså°ºå¯¸
                const canvas = document.getElementById('wordcloud-canvas');
                const rect = canvas.getBoundingClientRect();
                canvas.width = rect.width || 800;
                canvas.height = rect.height || 600;
                
                // åˆå§‹åŒ–ç©ºè¯äº‘
                updateWordCloud();
            });

            // çª—å£å¤§å°æ”¹å˜æ—¶é‡æ–°ç»˜åˆ¶
            let resizeTimer;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimer);
                resizeTimer = setTimeout(() => {
                    const canvas = document.getElementById('wordcloud-canvas');
                    const rect = canvas.getBoundingClientRect();
                    canvas.width = rect.width;
                    canvas.height = rect.height;
                    updateWordCloud();
                }, 300);
            });

            // é‡ç½®æŒ‰é’®åŠŸèƒ½
            const resetBtn = document.getElementById('resetBtn');
            resetBtn.addEventListener('click', () => {
                // æ¸…ç©ºæ‰€æœ‰æ•°æ®
                Object.keys(wordCount).forEach(key => delete wordCount[key]);
                placedWords.length = 0;
                Object.keys(wordProperties).forEach(key => delete wordProperties[key]);
                usedColors.length = 0;
                
                console.log('âœ“ è¯äº‘å·²é‡ç½®');
                
                // é‡æ–°æ¸²æŸ“ç©ºè¯äº‘
                updateWordCloud();
            });
        }); // DOMContentLoadedç»“æŸ
    </script>
</body>
</html>

